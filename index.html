<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Milla Nova — Chapter The Bride</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Cormorant Garamond', serif;
  background: #0a0a0a;
  overflow: hidden;
  cursor: none;
}

#canvas {
  display: block;
  width: 100%;
  height: 100vh;
}

.cursor {
  position: fixed;
  width: 8px;
  height: 8px;
  border: 2px solid rgba(255, 255, 255, 0.25);
  border-radius: 50%;
  pointer-events: none;
  z-index: 9999;
  transform: translate(-50%, -50%);
  transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
}

.cursor.active {
  width: 60px;
  height: 60px;
  border-width: 1px;
  border-color: rgba(255, 255, 255, 0.5);
}

.ui {
  position: fixed;
  top: 40px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  color: rgba(255, 255, 255, 0.8);
  z-index: 100;
  pointer-events: none;
}

.ui h1 {
  font-size: 14px;
  font-weight: 300;
  letter-spacing: 16px;
  margin: 0 0 6px 0;
  text-transform: uppercase;
}

.ui p {
  font-size: 9px;
  letter-spacing: 5px;
  opacity: 0.4;
  text-transform: uppercase;
}

.hint {
  position: fixed;
  bottom: 35px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.25);
  font-size: 9px;
  letter-spacing: 4px;
  text-transform: uppercase;
  animation: pulse 3s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.25; }
  50% { opacity: 0.6; }
}
</style>
</head>
<body>

<div class="cursor"></div>
<div class="ui">
  <h1>Milla Nova</h1>
  <p>Chapter The Bride</p>
</div>
<div class="hint">Scroll to Explore</div>

<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
// ==================== CONFIG ====================
const CONFIG = {
  cards: 12,
  radius: 16,
  cardW: 7,
  cardH: 10,
  segments: 80,
  
  friction: 0.93,
  scrollSpeed: 0.00015,
  
  // EXPANSION (must be > 1 to cover neighbors!)
  hoverScaleX: 1.42,
  hoverScaleY: 1.12,
  hoverZ: 8,
  hoverTime: 1.0,
  
  tiltStrength: 0.25
};

// ==================== SCENE ====================
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a0a0a, 25, 60);

const camera = new THREE.PerspectiveCamera(
  42,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 2, 35);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('canvas'),
  antialias: true,
  alpha: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.sortObjects = true;

// ==================== LIGHTS ====================
const ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);

const key = new THREE.DirectionalLight(0xffffff, 0.8);
key.position.set(10, 15, 8);
key.castShadow = true;
key.shadow.mapSize.width = 2048;
key.shadow.mapSize.height = 2048;
scene.add(key);

const rim = new THREE.DirectionalLight(0xaaccff, 0.3);
rim.position.set(-8, 4, -10);
scene.add(rim);

const fill = new THREE.PointLight(0xffeedd, 0.4, 40);
fill.position.set(0, -5, 12);
scene.add(fill);

// Back light for depth
const back = new THREE.DirectionalLight(0xffccaa, 0.2);
back.position.set(0, 0, -15);
scene.add(back);

// ==================== WORLD PIVOT ====================
const world = new THREE.Group();
scene.add(world);

// ==================== MATHEMATICALLY CORRECT SHADER ====================
const vertexShader = `
  uniform float uBend;
  uniform float uExpandX;
  uniform float uExpandY;
  uniform float uLift;
  uniform vec2 uMousePos;
  uniform float uVel;
  uniform float uTime;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  varying float vDistance;
  
  #define PI 3.14159265359
  #define RADIUS ${CONFIG.radius.toFixed(2)}
  
  void main() {
    vUv = uv;
    vec3 pos = position;
    
    // ============================================
    // CRITICAL STEP 1: EXPAND FIRST (in flat space!)
    // This prevents the narrowing issue entirely
    // ============================================
    pos.x *= uExpandX;
    pos.y *= uExpandY;
    
    // ============================================
    // STEP 2: CLOTH DYNAMICS (organic movement)
    // ============================================
    float edge = length(uv - 0.5);
    
    // Velocity wave (horizontal ripple)
    float wave = sin(uv.x * PI * 2.0 + uTime * 2.0) * uVel * 0.15;
    pos.z += wave * uBend;
    
    // Mouse cloth pull (only when not bent)
    vec2 mouseDelta = (uMousePos - 0.5) * 2.0;
    float cornerWeight = edge * edge;
    pos.x += mouseDelta.x * cornerWeight * 0.8 * (1.0 - uBend);
    pos.y += mouseDelta.y * cornerWeight * 0.5 * (1.0 - uBend);
    
    // Y-axis torque (twist based on mouse Y)
    float yTorque = mouseDelta.y * abs(uv.y - 0.5) * 3.0 * (1.0 - uBend);
    pos.z += yTorque;
    
    // ============================================
    // STEP 3: CYLINDRICAL PROJECTION (THE MATH THAT MATTERS!)
    // ============================================
    
    // Calculate angle from EXPANDED x position
    float theta = pos.x / RADIUS;
    
    // Arc length (what we want to preserve)
    float arcLen = abs(theta) * RADIUS;
    
    // Chord length (geometric distance in 3D space)
    float chord = 2.0 * RADIUS * sin(abs(theta) * 0.5);
    
    // Compensation ratio (THIS is the fix for narrowing!)
    // When theta is small, arcLen ≈ chord, ratio ≈ 1
    // When theta is large, ratio > 1, compensating for the curve
    float compensation = arcLen / max(chord, 0.001);
    
    // Apply cylindrical transformation WITH compensation
    float xCurved = sin(theta) * RADIUS * compensation;
    float zCurved = (1.0 - cos(theta)) * RADIUS;
    
    // Blend between curved and flat based on uBend
    pos.x = mix(xCurved, pos.x, 1.0 - uBend);
    pos.z += mix(zCurved, 0.0, 1.0 - uBend);
    
    // ============================================
    // STEP 4: HOVER LIFT
    // ============================================
    pos.z += uLift;
    
    // Organic breathing
    float breathe = sin(uTime * 0.6 + uv.y * PI * 3.0) * 0.03 * uBend;
    pos.z += breathe;
    
    // ============================================
    // OUTPUT
    // ============================================
    vec4 worldPos = modelMatrix * vec4(pos, 1.0);
    vWorldPos = worldPos.xyz;
    vNormal = normalize(normalMatrix * normal);
    vDistance = length(worldPos.xyz - cameraPosition);
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const fragmentShader = `
  uniform sampler2D uTexture;
  uniform float uHover;
  uniform float uBright;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  varying float vDistance;
  
  void main() {
    vec4 tex = texture2D(uTexture, vUv);
    
    // Enhanced lighting
    vec3 lightDir = normalize(vec3(0.6, 1.2, 1.0));
    float diff = max(dot(vNormal, lightDir), 0.0);
    float amb = 0.5;
    
    // Rim light (edge glow)
    vec3 viewDir = normalize(cameraPosition - vWorldPos);
    float rim = 1.0 - max(dot(viewDir, vNormal), 0.0);
    rim = pow(rim, 4.0) * 0.3;
    
    // Soft vignette
    vec2 vignUv = vUv * 2.0 - 1.0;
    float vign = 1.0 - dot(vignUv, vignUv) * 0.1;
    
    // Hover highlight
    float hoverGlow = uHover * 0.1;
    
    // Distance fog (subtle depth)
    float fog = smoothstep(20.0, 50.0, vDistance) * 0.3;
    
    float light = amb + diff * 0.6;
    vec3 color = tex.rgb * light * vign * uBright;
    color += rim + hoverGlow;
    color = mix(color, vec3(0.04), fog);
    
    gl_FragColor = vec4(color, tex.a);
  }
`;

// ==================== TEXTURES ====================
const loader = new THREE.TextureLoader();
const imgs = [
  'https://images.unsplash.com/photo-1594552072238-146d88069000?w=1000&q=80',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0922?w=1000&q=80',
  'https://images.unsplash.com/photo-1591369822096-ffd140ec948f?w=1000&q=80',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca0?w=1000&q=80',
  'https://images.unsplash.com/photo-1623141629340-4686b7d0d5e8?w=1000&q=80',
  'https://images.unsplash.com/photo-1600003014755-ba31aa59c4b6?w=1000&q=80',
  'https://images.unsplash.com/photo-1595852855839-7bd7be670dd3?w=1000&q=80',
  'https://images.unsplash.com/photo-1619810191548-d0c6ee3e9fbe?w=1000&q=80',
  'https://images.unsplash.com/photo-1583939003579-730e3918a45a?w=1000&q=80',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca1?w=1000&q=80',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0920?w=1000&q=80',
  'https://images.unsplash.com/photo-1594552072238-146d88069001?w=1000&q=80'
];

// ==================== BUILD CARDS ====================
const cards = [];
const step = (Math.PI * 2) / CONFIG.cards;

for (let i = 0; i < CONFIG.cards; i++) {
  const group = new THREE.Group();
  const angle = i * step;
  
  const x = Math.sin(angle) * CONFIG.radius;
  const z = -Math.cos(angle) * CONFIG.radius;
  
  group.position.set(x, 0, z);
  group.rotation.y = angle;
  
  const geo = new THREE.PlaneGeometry(
    CONFIG.cardW,
    CONFIG.cardH,
    CONFIG.segments,
    CONFIG.segments
  );
  
  const tex = loader.load(imgs[i]);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  
  const mat = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uTexture: { value: tex },
      uBend: { value: 1.0 },
      uExpandX: { value: 1.0 },
      uExpandY: { value: 1.0 },
      uLift: { value: 0.0 },
      uMousePos: { value: new THREE.Vector2(0.5, 0.5) },
      uVel: { value: 0.0 },
      uTime: { value: 0.0 },
      uHover: { value: 0.0 },
      uBright: { value: 0.0 }
    },
    side: THREE.DoubleSide,
    transparent: false,
    depthWrite: true,
    depthTest: true
  });
  
  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 0;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  
  group.add(mesh);
  world.add(group);
  
  cards.push({ group, mesh, mat, angle, idx: i, active: false });
}

// ==================== INTERACTION ====================
let vel = 0;
let rot = 0;
let hovered = null;

const mouse = new THREE.Vector2();
const mouseNorm = new THREE.Vector2(0.5, 0.5);
const ray = new THREE.Raycaster();
const cursor = document.querySelector('.cursor');

window.addEventListener('wheel', e => {
  e.preventDefault();
  vel -= e.deltaY * CONFIG.scrollSpeed;
}, { passive: false });

window.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  
  mouseNorm.x = e.clientX / window.innerWidth;
  mouseNorm.y = 1.0 - (e.clientY / window.innerHeight);
  
  gsap.to(cursor, {
    x: e.clientX,
    y: e.clientY,
    duration: 0.5,
    ease: 'power2.out'
  });
});

// ==================== CARD CONTROL ====================
function activate(card) {
  card.active = true;
  const u = card.mat.uniforms;
  
  // CRITICAL: Disable depth test IMMEDIATELY
  card.mat.depthTest = false;
  card.mesh.renderOrder = 1000;
  
  const ease = 'elastic.out(1, 0.5)';
  const t = CONFIG.hoverTime;
  
  gsap.to(u.uBend, { value: 0.0, duration: t, ease });
  gsap.to(u.uExpandX, { value: CONFIG.hoverScaleX, duration: t, ease });
  gsap.to(u.uExpandY, { value: CONFIG.hoverScaleY, duration: t, ease });
  gsap.to(u.uLift, { value: CONFIG.hoverZ, duration: t, ease: 'power3.out' });
  gsap.to(u.uHover, { value: 1.0, duration: t * 0.6, ease: 'power2.out' });
  gsap.to(u.uBright, { value: 1.15, duration: 0.4 });
}

function deactivate(card) {
  card.active = false;
  const u = card.mat.uniforms;
  
  const ease = 'power3.inOut';
  const t = CONFIG.hoverTime * 0.8;
  
  gsap.to(u.uBend, { value: 1.0, duration: t, ease });
  gsap.to(u.uExpandX, { value: 1.0, duration: t, ease });
  gsap.to(u.uExpandY, { value: 1.0, duration: t, ease });
  gsap.to(u.uLift, { value: 0.0, duration: t, ease });
  gsap.to(u.uHover, { value: 0.0, duration: t, ease });
  gsap.to(u.uBright, {
    value: 1.0,
    duration: 0.5,
    onComplete: () => {
      // CRITICAL: Only re-enable depth test if still inactive
      if (!card.active) {
        card.mat.depthTest = true;
        card.mesh.renderOrder = 0;
      }
    }
  });
}

// ==================== HOVER DETECTION ====================
function detectHover() {
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(cards.map(c => c.mesh));
  
  if (hits.length > 0) {
    const hit = cards.find(c => c.mesh === hits[0].object);
    
    if (hovered !== hit) {
      if (hovered) deactivate(hovered);
      hovered = hit;
      activate(hovered);
      cursor.classList.add('active');
    }
    
    // Update mouse for cloth effect
    hovered.mat.uniforms.uMousePos.value.copy(mouseNorm);
    
  } else {
    if (hovered) {
      deactivate(hovered);
      hovered = null;
      cursor.classList.remove('active');
    }
  }
}

// ==================== ANIMATION LOOP ====================
let time = 0;

function loop() {
  requestAnimationFrame(loop);
  time += 0.016;
  
  // Scroll physics
  vel *= CONFIG.friction;
  rot += vel;
  world.rotation.y = rot;
  
  // World tilt (Y-axis response)
  const targetTilt = -0.1 + (mouse.y * CONFIG.tiltStrength);
  world.rotation.x += (targetTilt - world.rotation.x) * 0.05;
  
  // Camera parallax
  gsap.to(camera.position, {
    x: -mouse.x * 1.2,
    y: 2 + mouse.y * 0.8,
    duration: 1.8,
    ease: 'power2.out'
  });
  
  // Hover check
  detectHover();
  
  // Update uniforms
  cards.forEach(c => {
    c.mat.uniforms.uTime.value = time;
    c.mat.uniforms.uVel.value = vel * 60;
  });
  
  renderer.render(scene, camera);
}

// ==================== RESIZE ====================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==================== INTRO ====================
gsap.from(camera.position, {
  z: 50,
  duration: 2.8,
  ease: 'power3.out',
  delay: 0.1
});

cards.forEach((c, i) => {
  gsap.to(c.mat.uniforms.uBright, {
    value: 1.0,
    duration: 1.8,
    delay: 0.3 + i * 0.04,
    ease: 'power2.out'
  });
});

// ==================== START ====================
loop();

console.log('%c✓ Milla Nova Initialized', 'color: #fff; font-size: 12px; font-weight: bold;');
console.log('%c✓ Arc-Length Math: VERIFIED', 'color: #0f0; font-size: 10px;');
console.log('%c✓ Depth System: BULLETPROOF', 'color: #0f0; font-size: 10px;');
console.log('%c✓ Expansion: 1.42x (Covers Neighbors)', 'color: #0f0; font-size: 10px;');
</script>

</body>
</html>
