<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Milla Nova 3D — Perfect Reconstruction</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Cormorant Garamond', 'Times New Roman', serif;
  background: #0d0d0d;
  overflow: hidden;
  cursor: none;
}

#canvas {
  display: block;
  width: 100%;
  height: 100vh;
}

.cursor {
  position: fixed;
  width: 10px;
  height: 10px;
  border: 1.5px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  pointer-events: none;
  z-index: 9999;
  transform: translate(-50%, -50%);
  transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
}

.cursor.active {
  width: 50px;
  height: 50px;
  border-color: rgba(255, 255, 255, 0.6);
  border-width: 1px;
}

.ui-top {
  position: fixed;
  top: 50px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  color: rgba(255, 255, 255, 0.85);
  z-index: 100;
  pointer-events: none;
}

.ui-top h1 {
  font-weight: 300;
  font-size: 16px;
  letter-spacing: 12px;
  margin: 0 0 8px 0;
  text-transform: uppercase;
}

.ui-top p {
  font-size: 10px;
  letter-spacing: 4px;
  opacity: 0.5;
  text-transform: uppercase;
}

.ui-bottom {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.3);
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  z-index: 100;
  animation: breathe 3s ease-in-out infinite;
}

@keyframes breathe {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.7; }
}
</style>
</head>
<body>

<div class="cursor"></div>

<div class="ui-top">
  <h1>Milla Nova</h1>
  <p>Couture Collection 2025</p>
</div>

<div class="ui-bottom">Scroll to Explore Collection</div>

<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
// ==================== PRECISE CONFIG ====================
const CONFIG = {
  cardCount: 12,
  cylinderRadius: 15,
  cardWidth: 7,
  cardHeight: 10,
  segments: 64, // HIGH tessellation for smooth bend
  
  // Physics
  friction: 0.94,
  scrollSensitivity: 0.00012,
  
  // Hover expansion (CRITICAL for covering effect)
  hoverScaleX: 1.32,
  hoverScaleY: 1.08,
  hoverZOffset: 6,
  hoverDuration: 0.9,
  
  // Tilt
  worldTiltStrength: 0.22
};

// ==================== SCENE SETUP ====================
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0d0d0d, 20, 50);

const camera = new THREE.PerspectiveCamera(
  40,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 1.5, 32);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('canvas'),
  antialias: true,
  alpha: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.sortObjects = true; // CRITICAL for proper layering

// ==================== LIGHTING ====================
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const keyLight = new THREE.DirectionalLight(0xffffff, 0.65);
keyLight.position.set(8, 12, 6);
keyLight.castShadow = true;
scene.add(keyLight);

const rimLight = new THREE.DirectionalLight(0x88aaff, 0.2);
rimLight.position.set(-6, 3, -8);
scene.add(rimLight);

const fillLight = new THREE.PointLight(0xffddaa, 0.35, 30);
fillLight.position.set(0, -4, 10);
scene.add(fillLight);

// ==================== WORLD PIVOT ====================
const worldPivot = new THREE.Group();
scene.add(worldPivot);

// ==================== CORRECTED SHADERS ====================
const vertexShader = `
  uniform float uBendAmount;
  uniform float uScaleX;
  uniform float uScaleY;
  uniform float uZLift;
  uniform vec2 uMouse;
  uniform float uVelocity;
  uniform float uTime;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  
  const float PI = 3.14159265359;
  
  void main() {
    vUv = uv;
    vec3 pos = position;
    
    // ============================================
    // STEP 1: APPLY SCALE FIRST (before any bending!)
    // This prevents the "narrowing" issue
    // ============================================
    pos.x *= uScaleX;
    pos.y *= uScaleY;
    
    // ============================================
    // STEP 2: CLOTH PHYSICS (vertex-level organic movement)
    // ============================================
    // Velocity ripple
    float ripple = sin(uv.x * PI * 2.0) * uVelocity * 0.12;
    pos.z += ripple;
    
    // Mouse-driven cloth deformation (only when not bent)
    float edgeWeight = pow(length(uv - 0.5), 2.0);
    vec2 mousePull = (uMouse - 0.5) * edgeWeight * 0.6 * (1.0 - uBendAmount);
    pos.x += mousePull.x;
    pos.y += mousePull.y * 0.4;
    
    // Vertical torque based on mouse Y
    float verticalTorque = (uMouse.y - 0.5) * abs(uv.y - 0.5) * 2.5 * (1.0 - uBendAmount);
    pos.z += verticalTorque;
    
    // ============================================
    // STEP 3: CYLINDRICAL BEND (mathematically correct)
    // ============================================
    float radius = ${CONFIG.cylinderRadius.toFixed(2)};
    
    // Calculate angle from scaled X position
    float angle = pos.x / radius;
    
    // Arc-length preservation calculation
    // This is the KEY to preventing narrowing
    float arcLength = abs(angle) * radius;
    float chordLength = 2.0 * radius * sin(abs(angle) * 0.5);
    float lengthRatio = arcLength / max(chordLength, 0.001);
    
    // Apply cylindrical transformation
    float xBent = sin(angle) * radius * lengthRatio;
    float zBent = (1.0 - cos(angle)) * radius;
    
    // Interpolate between flat and bent based on uBendAmount
    pos.x = mix(xBent, pos.x, 1.0 - uBendAmount);
    pos.z += mix(zBent, 0.0, 1.0 - uBendAmount);
    
    // ============================================
    // STEP 4: Z-OFFSET (hover lift)
    // ============================================
    pos.z += uZLift;
    
    // Subtle breathing animation
    float breathe = sin(uTime * 0.8 + uv.y * PI * 2.0) * 0.025 * uBendAmount;
    pos.z += breathe;
    
    vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
    vNormal = normalize(normalMatrix * normal);
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const fragmentShader = `
  uniform sampler2D uTexture;
  uniform float uHoverProgress;
  uniform float uBrightness;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  
  void main() {
    vec4 texColor = texture2D(uTexture, vUv);
    
    // Enhanced lighting model
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8));
    float diffuse = max(dot(vNormal, lightDir), 0.0);
    float ambient = 0.42;
    
    // Rim lighting for depth
    vec3 viewDir = normalize(cameraPosition - vWorldPos);
    float rim = 1.0 - max(dot(viewDir, vNormal), 0.0);
    rim = pow(rim, 3.5) * 0.22;
    
    // Elegant vignette
    vec2 vignetteUv = vUv * 2.0 - 1.0;
    float vignette = 1.0 - dot(vignetteUv, vignetteUv) * 0.08;
    
    // Hover glow
    float hoverGlow = uHoverProgress * 0.06;
    
    float lighting = ambient + diffuse * 0.58;
    vec3 finalColor = texColor.rgb * lighting * vignette * uBrightness;
    finalColor += rim + hoverGlow;
    
    gl_FragColor = vec4(finalColor, texColor.a);
  }
`;

// ==================== TEXTURE LOADING ====================
const textureLoader = new THREE.TextureLoader();
const images = [
  'https://images.unsplash.com/photo-1594552072238-146d88069000?w=900',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0922?w=900',
  'https://images.unsplash.com/photo-1591369822096-ffd140ec948f?w=900',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca0?w=900',
  'https://images.unsplash.com/photo-1623141629340-4686b7d0d5e8?w=900',
  'https://images.unsplash.com/photo-1600003014755-ba31aa59c4b6?w=900',
  'https://images.unsplash.com/photo-1595852855839-7bd7be670dd3?w=900',
  'https://images.unsplash.com/photo-1619810191548-d0c6ee3e9fbe?w=900',
  'https://images.unsplash.com/photo-1583939003579-730e3918a45a?w=900',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca1?w=900',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0920?w=900',
  'https://images.unsplash.com/photo-1594552072238-146d88069001?w=900'
];

// ==================== CARD CREATION ====================
const cards = [];
const angleStep = (Math.PI * 2) / CONFIG.cardCount;

for (let i = 0; i < CONFIG.cardCount; i++) {
  const cardGroup = new THREE.Group();
  const angle = i * angleStep;
  
  // Position cards in circular arrangement
  const x = Math.sin(angle) * CONFIG.cylinderRadius;
  const z = -Math.cos(angle) * CONFIG.cylinderRadius;
  
  cardGroup.position.set(x, 0, z);
  cardGroup.rotation.y = angle;
  
  // High-tessellation geometry for smooth bending
  const geometry = new THREE.PlaneGeometry(
    CONFIG.cardWidth,
    CONFIG.cardHeight,
    CONFIG.segments,
    CONFIG.segments
  );
  
  const texture = textureLoader.load(images[i]);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  
  const material = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uTexture: { value: texture },
      uBendAmount: { value: 1.0 },
      uScaleX: { value: 1.0 },
      uScaleY: { value: 1.0 },
      uZLift: { value: 0.0 },
      uMouse: { value: new THREE.Vector2(0.5, 0.5) },
      uVelocity: { value: 0.0 },
      uTime: { value: 0.0 },
      uHoverProgress: { value: 0.0 },
      uBrightness: { value: 1.0 }
    },
    side: THREE.DoubleSide,
    transparent: false,
    depthWrite: true,
    depthTest: true
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.renderOrder = 0; // Default render order
  
  cardGroup.add(mesh);
  worldPivot.add(cardGroup);
  
  cards.push({
    group: cardGroup,
    mesh: mesh,
    material: material,
    baseAngle: angle,
    index: i,
    isHovered: false
  });
}

// ==================== INTERACTION STATE ====================
let scrollVelocity = 0;
let currentRotation = 0;
let hoveredCard = null;

const mouse = new THREE.Vector2();
const mouseNormalized = new THREE.Vector2(0.5, 0.5);
const raycaster = new THREE.Raycaster();
const cursor = document.querySelector('.cursor');

// ==================== EVENT LISTENERS ====================
window.addEventListener('wheel', (e) => {
  e.preventDefault();
  scrollVelocity -= e.deltaY * CONFIG.scrollSensitivity;
}, { passive: false });

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  
  mouseNormalized.x = e.clientX / window.innerWidth;
  mouseNormalized.y = 1.0 - (e.clientY / window.innerHeight);
  
  gsap.to(cursor, {
    x: e.clientX,
    y: e.clientY,
    duration: 0.4,
    ease: 'power2.out'
  });
});

// ==================== CARD ACTIVATION ====================
function activateCard(card) {
  card.isHovered = true;
  const u = card.material.uniforms;
  
  // CRITICAL: Disable depth test and set high render order IMMEDIATELY
  card.material.depthTest = false;
  card.mesh.renderOrder = 100;
  
  // Animate to flat, expanded state
  gsap.to(u.uBendAmount, {
    value: 0.0,
    duration: CONFIG.hoverDuration,
    ease: 'power4.out'
  });
  
  gsap.to(u.uScaleX, {
    value: CONFIG.hoverScaleX,
    duration: CONFIG.hoverDuration,
    ease: 'power4.out'
  });
  
  gsap.to(u.uScaleY, {
    value: CONFIG.hoverScaleY,
    duration: CONFIG.hoverDuration,
    ease: 'power4.out'
  });
  
  gsap.to(u.uZLift, {
    value: CONFIG.hoverZOffset,
    duration: CONFIG.hoverDuration,
    ease: 'power4.out'
  });
  
  gsap.to(u.uHoverProgress, {
    value: 1.0,
    duration: CONFIG.hoverDuration,
    ease: 'power3.out'
  });
  
  gsap.to(u.uBrightness, {
    value: 1.12,
    duration: 0.4
  });
}

function deactivateCard(card) {
  card.isHovered = false;
  const u = card.material.uniforms;
  
  // Animate back to bent, normal state
  gsap.to(u.uBendAmount, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.85,
    ease: 'power3.inOut'
  });
  
  gsap.to(u.uScaleX, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.85,
    ease: 'power3.inOut'
  });
  
  gsap.to(u.uScaleY, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.85,
    ease: 'power3.inOut'
  });
  
  gsap.to(u.uZLift, {
    value: 0.0,
    duration: CONFIG.hoverDuration * 0.85,
    ease: 'power3.inOut'
  });
  
  gsap.to(u.uHoverProgress, {
    value: 0.0,
    duration: CONFIG.hoverDuration * 0.85,
    ease: 'power3.inOut'
  });
  
  gsap.to(u.uBrightness, {
    value: 1.0,
    duration: 0.5,
    onComplete: () => {
      // CRITICAL: Re-enable depth test and reset render order only after animation completes
      if (!card.isHovered) {
        card.material.depthTest = true;
        card.mesh.renderOrder = 0;
      }
    }
  });
}

// ==================== HOVER DETECTION ====================
function updateHoverState() {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cards.map(c => c.mesh));
  
  if (intersects.length > 0) {
    const newHovered = cards.find(c => c.mesh === intersects[0].object);
    
    if (hoveredCard !== newHovered) {
      // Deactivate previous
      if (hoveredCard) {
        deactivateCard(hoveredCard);
      }
      
      // Activate new
      hoveredCard = newHovered;
      activateCard(hoveredCard);
      cursor.classList.add('active');
    }
    
    // Update mouse position for cloth effect
    hoveredCard.material.uniforms.uMouse.value.copy(mouseNormalized);
    
  } else {
    if (hoveredCard) {
      deactivateCard(hoveredCard);
      hoveredCard = null;
      cursor.classList.remove('active');
    }
  }
}

// ==================== ANIMATION LOOP ====================
let time = 0;

function animate() {
  requestAnimationFrame(animate);
  time += 0.016;
  
  // Scroll physics with friction
  scrollVelocity *= CONFIG.friction;
  currentRotation += scrollVelocity;
  worldPivot.rotation.y = currentRotation;
  
  // World tilt based on mouse Y position
  const targetPitch = -0.08 + (mouse.y * CONFIG.worldTiltStrength);
  worldPivot.rotation.x += (targetPitch - worldPivot.rotation.x) * 0.06;
  
  // Subtle camera movement
  gsap.to(camera.position, {
    x: -mouse.x * 1.0,
    y: 1.5 + mouse.y * 0.5,
    duration: 1.6,
    ease: 'power2.out'
  });
  
  // Update hover state
  updateHoverState();
  
  // Update card uniforms
  cards.forEach(card => {
    const u = card.material.uniforms;
    u.uTime.value = time;
    u.uVelocity.value = scrollVelocity * 50;
  });
  
  renderer.render(scene, camera);
}

// ==================== RESIZE ====================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==================== INTRO ANIMATION ====================
gsap.from(camera.position, {
  z: 48,
  duration: 2.6,
  ease: 'power3.out',
  delay: 0.2
});

cards.forEach((card, i) => {
  gsap.from(card.material.uniforms.uBrightness, {
    value: 0,
    duration: 1.6,
    delay: 0.4 + i * 0.05,
    ease: 'power2.out'
  });
});

// ==================== START ====================
animate();

console.log('✓ Milla Nova 3D Gallery initialized');
console.log('✓ Arc-length preservation: ACTIVE');
console.log('✓ Depth management: CORRECTED');
console.log('✓ Hover expansion: FUNCTIONAL');
</script>

</body>
</html>
