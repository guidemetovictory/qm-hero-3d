<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QM Hero 3D – Cards Ring</title>

  <style>
    :root{
      --bg: #ffffff;
      --card-bg: rgba(0,0,0,0.16);
    }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; }

    #wrap{
      position:relative;
      width:100vw; height:100vh;
      overflow:hidden;
      background:var(--bg);
    }

    /* Make sure the canvas fills the viewport and stays behind overlays */
    canvas{
      position:absolute;
      inset:0;
      display:block;
      z-index:1;
    }

    #grain{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:2;
      mix-blend-mode:multiply;
      opacity:.18;
      background:
        radial-gradient(circle at 20% 10%, rgba(0,0,0,.10), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(0,0,0,.06), transparent 60%),
        radial-gradient(circle at 50% 80%, rgba(0,0,0,.08), transparent 55%);
      filter: blur(20px);
    }

    #hint{
      position:absolute;
      top:14px; left:14px;
      z-index:3;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#0b0b0b;
      opacity:.55;
      user-select:none;
      pointer-events:none;
    }

    /* Optional: debug border to confirm full-screen */
    /* #wrap{ outline:1px solid red; } */
  </style>
</head>

<body>
  <div id="wrap">
    <div id="hint">Move mouse • Smooth ring • Paper bend</div>
    <div id="grain"></div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // -----------------------------
    // Scene / Camera / Renderer
    // -----------------------------
    const wrap = document.getElementById("wrap");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(48, wrap.clientWidth / wrap.clientHeight, 0.1, 80);
    camera.position.set(0, 0.15, 7.2); // closer & wider than before

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    // Light (subtle)
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(2, 3, 4);
    scene.add(dir);

    // -----------------------------
    // Shaders (paper bend)
    // -----------------------------
    const vertex = /* glsl */`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uBend;
      uniform float uHover;

      void main(){
        vUv = uv;

        vec3 p = position;

        // Paper-bend: curve along X, stronger on hover
        float bend = uBend + uHover * 0.55;
        float k = (p.x) * 0.55;
        p.z += sin(k) * bend;

        // tiny breathing to avoid "dead" look
        p.z += sin(uTime * 0.6 + p.y * 1.8) * 0.003;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `;

    const fragment = /* glsl */`
      varying vec2 vUv;
      uniform sampler2D uMap;

      void main(){
        vec4 tex = texture2D(uMap, vUv);

        // If texture has transparency, keep it. Otherwise show full plane.
        // Slightly lift contrast to feel like "paper".
        vec3 col = tex.rgb;
        col = pow(col, vec3(0.95));

        gl_FragColor = vec4(col, tex.a);
      }
    `;

    function makePaperMaterial(map){
      return new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.DoubleSide,     // IMPORTANT: prevent "missing half ring"
        uniforms:{
          uTime:{ value:0 },
          uBend:{ value:0.22 },
          uHover:{ value:0.0 },
          uMap:{ value: map }
        },
        vertexShader: vertex,
        fragmentShader: fragment
      });
    }

    // -----------------------------
    // Cards ring
    // -----------------------------
    const group = new THREE.Group();
    scene.add(group);

    const CARD_W = 2.05;
    const CARD_H = 2.80;
    const SEG_X = 36;
    const SEG_Y = 18;

    const N = 10;
    const R = 3.85; // smaller so it fits camera frustum reliably

    function makeCardTexture(label){
      const c = document.createElement("canvas");
      c.width = 900; c.height = 1200;
      const g = c.getContext("2d");

      // background (your requested vibe)
      g.fillStyle = "rgba(0,0,0,0.16)";
      g.fillRect(0,0,c.width,c.height);

      // soft highlight
      const grd = g.createRadialGradient(250,220,40, 260,260,700);
      grd.addColorStop(0,"rgba(255,255,255,0.18)");
      grd.addColorStop(1,"rgba(255,255,255,0.00)");
      g.fillStyle = grd;
      g.fillRect(0,0,c.width,c.height);

      // border
      g.strokeStyle = "rgba(255,255,255,0.22)";
      g.lineWidth = 6;
      g.strokeRect(40,40,c.width-80,c.height-80);

      // label
      g.fillStyle = "rgba(15,15,15,0.88)";
      g.font = "700 82px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText(label, 90, 160);

      // subtext
      g.fillStyle = "rgba(15,15,15,0.55)";
      g.font = "500 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText("QM card", 90, 235);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.needsUpdate = true;
      return tex;
    }

    const cards = [];
    for(let i=0;i<N;i++){
      const geo = new THREE.PlaneGeometry(CARD_W, CARD_H, SEG_X, SEG_Y);
      const tex = makeCardTexture(`Card ${i+1}`);
      const mat = makePaperMaterial(tex);
      const mesh = new THREE.Mesh(geo, mat);

      const theta = i * (Math.PI * 2 / N);
      mesh.position.set(Math.cos(theta) * R, 0, Math.sin(theta) * R);

      // IMPORTANT: face the center (or outward) consistently
      // This makes the "front" predictable and avoids the "inward text" confusion.
      mesh.lookAt(0, 0, 0);
      mesh.rotateY(Math.PI); // flip so the "front" is facing camera when on near side

      group.add(mesh);

      cards.push({
        mesh,
        mat,
        theta,
        hover: 0
      });
    }

    // -----------------------------
    // Interaction: smooth "ring follow" + hover-ish bend
    // -----------------------------
    let targetRotY = 0;
    let rotY = 0;

    let mouseX = 0, mouseY = 0;
    window.addEventListener("mousemove", (e)=>{
      mouseX = (e.clientX / window.innerWidth) * 2 - 1; // -1..1
      mouseY = (e.clientY / window.innerHeight) * 2 - 1; // -1..1

      // Rotate ring by mouse X
      targetRotY = mouseX * 0.55;
    }, { passive:true });

    // simple raycaster hover (optional but useful)
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    function updateHover(){
      ndc.x = mouseX;
      ndc.y = -mouseY;

      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(cards.map(c=>c.mesh), false);

      // decay all
      for(const c of cards) c.hover *= 0.90;

      if(hits.length){
        const hit = hits[0].object;
        const c = cards.find(x=>x.mesh === hit);
        if(c) c.hover = Math.min(1, c.hover + 0.20);
      }
    }

    // -----------------------------
    // Resize
    // -----------------------------
    function onResize(){
      camera.aspect = wrap.clientWidth / wrap.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    }
    window.addEventListener("resize", onResize);

    // -----------------------------
    // Animate
    // -----------------------------
    const clock = new THREE.Clock();

    function tick(){
      const t = clock.getElapsedTime();

      // smooth rotation (inertia-ish)
      rotY += (targetRotY - rotY) * 0.06;
      group.rotation.y = rotY;

      updateHover();

      // per-card paper bend
      for(const c of cards){
        c.mat.uniforms.uTime.value = t;
        c.mat.uniforms.uHover.value = c.hover;
      }

      // subtle camera parallax
      camera.position.x = mouseX * 0.18;
      camera.position.y = 0.15 + (-mouseY) * 0.10;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>
