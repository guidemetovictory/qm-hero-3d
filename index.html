<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milla Nova Couture - 1:1 Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #d1d1d1; font-family: serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; align-items: center; padding: 40px 0;
            z-index: 10;
        }
        h1 { font-weight: 100; letter-spacing: 12px; text-transform: uppercase; color: #222; font-size: 16px; }
        .footer { letter-spacing: 4px; text-transform: uppercase; font-size: 9px; color: #555; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Milla Nova — Couture</h1>
        <div class="footer">Scroll to explore collection 2025</div>
    </div>

    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js", 
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js" 
        } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { gsap } from 'gsap';

        // --- KONFIGURACE ---
        const SETTINGS = {
            radius: 22,
            cardCount: 12,
            cardWidth: 10,
            cardHeight: 14,
            lerpSpeed: 0.05
        };

        // --- SCÉNA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd1d1d1);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const worldPivot = new THREE.Group();
        scene.add(worldPivot);

        // --- SHADER (Fix pro úžení a prosekávání) ---
        const vertexShader = `
            uniform float uHover;
            uniform float uTorsion;
            varying vec2 vUv;

            void main() {
                vUv = uv;
                vec3 pos = position;

                // 1. ZACHOVÁNÍ ŠÍŘKY (Arc Length Preservation)
                // Počítáme úhel z neměnné pozice, aby se karta neúžila
                float radius = 22.0;
                float angle = position.x / radius;
                
                // Ohyb se narovnává podle uHover (1.0 = rovná karta)
                float bend = 1.0 - (uHover * 0.98); 
                
                // 2. TORZE (Osa Y)
                // Horní a spodní rohy se kroutí podle uTorsion
                float twist = sin(uv.y - 0.5) * uTorsion * uHover * 2.0;
                pos.z += twist;

                // 3. CYLINDRICKÁ TRANSFORMACE
                float newX = sin(angle * bend) * radius;
                float newZ = cos(angle * bend) * radius - radius;
                
                pos.x = newX;
                pos.z += newZ;

                // 4. VÝSTUP K DIVÁKOVI
                pos.z += uHover * 8.0;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform float uHover;
            varying vec2 vUv;
            void main() {
                vec4 tex = texture2D(uTexture, vUv);
                // Luxusní jemný overlay při hoveru
                gl_FragColor = vec4(tex.rgb + (uHover * 0.1), 1.0);
            }
        `;

        // --- TVORBA KARET ---
        const cards = [];
        const loader = new THREE.TextureLoader();

        for (let i = 0; i < SETTINGS.cardCount; i++) {
            const angle = (i / SETTINGS.cardCount) * Math.PI * 2;
            const container = new THREE.Group();

            const geo = new THREE.PlaneGeometry(SETTINGS.cardWidth, SETTINGS.cardHeight, 64, 64);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: loader.load(`https://picsum.photos/seed/${i + 50}/800/1200`) },
                    uHover: { value: 0 },
                    uTorsion: { value: 0 }
                },
                vertexShader,
                fragmentShader,
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geo, mat);
            
            // Umístění do kruhu
            container.position.x = Math.sin(angle) * SETTINGS.radius;
            container.position.z = Math.cos(angle) * SETTINGS.radius;
            container.rotation.y = angle;

            container.add(mesh);
            worldPivot.add(container);
            cards.push({ mesh, container });
        }

        // --- LOGIKA POHYBU ---
        let targetRotation = 0;
        let currentRotation = 0;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();

        window.addEventListener('wheel', (e) => {
            targetRotation -= e.deltaY * 0.001;
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // --- ANIMACE ---
        function animate() {
            requestAnimationFrame(animate);

            // Plynulá rotace
            currentRotation = THREE.MathUtils.lerp(currentRotation, targetRotation, SETTINGS.lerpSpeed);
            worldPivot.rotation.y = currentRotation;

            // Tilt celého světa podle Y osy myši
            worldPivot.rotation.x = THREE.MathUtils.lerp(worldPivot.rotation.x, mouse.y * 0.2, 0.05);

            // Raycasting
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards.map(c => c.mesh));
            const hoveredMesh = intersects.length > 0 ? intersects[0].object : null;

            cards.forEach(card => {
                const isHovered = card.mesh === hoveredMesh;
                const uniforms = card.mesh.material.uniforms;

                if (isHovered) {
                    // PŘEKRÝVÁNÍ: Aktivní karta jde nad všechno
                    card.mesh.renderOrder = 100;
                    card.mesh.material.depthTest = false;

                    gsap.to(uniforms.uHover, { value: 1.0, duration: 0.5, ease: "power2.out" });
                    // Expanze do šířky
                    gsap.to(card.mesh.scale, { x: 1.3, y: 1.05, duration: 0.5 });
                    // Dynamická torze podle myši
                    uniforms.uTorsion.value = THREE.MathUtils.lerp(uniforms.uTorsion.value, mouse.x * 0.5, 0.1);
                } else {
                    gsap.to(uniforms.uHover, { 
                        value: 0, 
                        duration: 0.6, 
                        onComplete: () => {
                            if(uniforms.uHover.value === 0) {
                                card.mesh.renderOrder = 0;
                                card.mesh.material.depthTest = true;
                            }
                        }
                    });
                    gsap.to(card.mesh.scale, { x: 1, y: 1, duration: 0.6 });
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
