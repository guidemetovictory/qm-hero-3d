<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Milla Nova 3D — 1:1 Perfect Reconstruction</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Cormorant Garamond', 'Times New Roman', serif;
  background: #0d0d0d;
  overflow: hidden;
  cursor: none;
}

#canvas {
  display: block;
  width: 100%;
  height: 100vh;
}

.cursor {
  position: fixed;
  width: 10px;
  height: 10px;
  border: 1.5px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  pointer-events: none;
  z-index: 9999;
  transform: translate(-50%, -50%);
  transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
}

.cursor.active {
  width: 50px;
  height: 50px;
  border-color: rgba(255, 255, 255, 0.6);
  border-width: 1px;
}

.ui-top {
  position: fixed;
  top: 50px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  color: rgba(255, 255, 255, 0.85);
  z-index: 100;
  pointer-events: none;
}

.ui-top h1 {
  font-weight: 300;
  font-size: 16px;
  letter-spacing: 12px;
  margin: 0 0 8px 0;
  text-transform: uppercase;
}

.ui-top p {
  font-size: 10px;
  letter-spacing: 4px;
  opacity: 0.5;
  text-transform: uppercase;
}

.ui-bottom {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.3);
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  z-index: 100;
  animation: breathe 3s ease-in-out infinite;
}

@keyframes breathe {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.7; }
}
</style>
</head>
<body>

<div class="cursor"></div>

<div class="ui-top">
  <h1>Milla Nova</h1>
  <p>Couture Collection 2025</p>
</div>

<div class="ui-bottom">Scroll to Explore Collection</div>

<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
// ==================== MASTER CONFIG ====================
const CONFIG = {
  cardCount: 12,
  cylinderRadius: 18.5,
  cardWidth: 9,
  cardHeight: 12,
  
  // Physics
  friction: 0.94,
  scrollSensitivity: 0.00008,
  
  // Hover
  hoverExpansionX: 1.28,
  hoverExpansionY: 1.06,
  hoverZOffset: 7.5,
  hoverDuration: 0.75,
  
  // Tilt
  worldTiltStrength: 0.28,
  
  // Tessellation (CRITICAL!)
  segments: 48 // High tessellation for smooth bend
};

// ==================== SCENE SETUP ====================
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0d0d0d, 15, 45);

const camera = new THREE.PerspectiveCamera(
  38,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 2.5, 38);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('canvas'),
  antialias: true,
  alpha: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// ==================== LIGHTING ====================
const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambientLight);

const keyLight = new THREE.DirectionalLight(0xffffff, 0.7);
keyLight.position.set(8, 12, 6);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width = 2048;
keyLight.shadow.mapSize.height = 2048;
scene.add(keyLight);

const rimLight = new THREE.DirectionalLight(0x88aaff, 0.25);
rimLight.position.set(-6, 3, -8);
scene.add(rimLight);

const fillLight = new THREE.PointLight(0xffddaa, 0.4, 30);
fillLight.position.set(0, -4, 10);
scene.add(fillLight);

// ==================== WORLD PIVOT ====================
const worldPivot = new THREE.Group();
scene.add(worldPivot);

// ==================== SHADERS ====================
const vertexShader = `
  uniform float uBendFactor;
  uniform float uExpansionX;
  uniform float uExpansionY;
  uniform float uZOffset;
  uniform float uVelocity;
  uniform vec2 uMouse;
  uniform float uTime;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vPosition;
  
  // CRITICAL: Arc-length preservation function
  float getArcCompensation(float angle) {
    float sinHalf = sin(angle * 0.5);
    if (abs(sinHalf) < 0.0001) return 1.0;
    return (angle * 0.5) / sinHalf;
  }
  
  void main() {
    vUv = uv;
    vec3 pos = position;
    
    // ============================================
    // PHASE 1: EXPANSION (Before bending!)
    // ============================================
    // This is where your original code failed - you expanded AFTER bending
    pos.x *= uExpansionX;
    pos.y *= uExpansionY;
    
    // ============================================
    // PHASE 2: CLOTH PHYSICS (Vertex-level deformation)
    // ============================================
    // Velocity wave (horizontal ripple)
    float velocityWave = sin(uv.x * 3.14159) * uVelocity * 0.15;
    
    // Mouse influence (vertical torsion) - cloth effect
    float edgeInfluence = pow(abs(uv.y - 0.5) * 2.0, 1.5);
    float mouseTorsion = uMouse.y * edgeInfluence * 3.0;
    
    // Corner warping (hadrový efekt)
    float cornerFactor = length(uv - 0.5) * 2.0;
    vec2 cornerWarp = (uMouse - 0.5) * cornerFactor * 0.4;
    
    pos.z += velocityWave + mouseTorsion;
    pos.x += cornerWarp.x * (1.0 - uBendFactor);
    pos.y += cornerWarp.y * 0.3;
    
    // ============================================
    // PHASE 3: CYLINDRICAL BEND (The math that fixes everything)
    // ============================================
    float r = ${CONFIG.cylinderRadius.toFixed(2)};
    
    // Calculate angle from x position
    float angle = pos.x / r;
    
    // Arc-length compensation (THIS IS THE KEY!)
    float compensation = getArcCompensation(angle);
    
    // Apply cylindrical transformation with compensation
    float xCurved = sin(angle) * r * compensation;
    float zCurved = (1.0 - cos(angle)) * r;
    
    // Blend between curved and flat based on bend factor
    pos.x = mix(xCurved, pos.x, 1.0 - uBendFactor);
    pos.z += mix(zCurved, 0.0, 1.0 - uBendFactor);
    
    // ============================================
    // PHASE 4: Z-OFFSET (Hover depth)
    // ============================================
    pos.z += uZOffset;
    
    // Organic breathing (subtle)
    float breathe = sin(uTime * 0.5 + uv.y * 6.28) * 0.03 * uBendFactor;
    pos.z += breathe;
    
    vPosition = pos;
    vNormal = normalize(normalMatrix * normal);
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const fragmentShader = `
  uniform sampler2D uTexture;
  uniform float uHoverProgress;
  uniform float uBrightness;
  
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vPosition;
  
  void main() {
    vec4 texColor = texture2D(uTexture, vUv);
    
    // Lighting
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8));
    float diffuse = max(dot(vNormal, lightDir), 0.0);
    float ambient = 0.45;
    
    // Rim light
    vec3 viewDir = normalize(cameraPosition - vPosition);
    float rim = 1.0 - max(dot(viewDir, vNormal), 0.0);
    rim = pow(rim, 3.0) * 0.25;
    
    // Vignette
    vec2 vignetteUv = vUv * 2.0 - 1.0;
    float vignette = 1.0 - dot(vignetteUv, vignetteUv) * 0.12;
    
    // Hover glow
    float hoverGlow = uHoverProgress * 0.08;
    
    float lighting = ambient + diffuse * 0.55;
    vec3 finalColor = texColor.rgb * lighting * vignette * uBrightness;
    finalColor += rim + hoverGlow;
    
    gl_FragColor = vec4(finalColor, texColor.a);
  }
`;

// ==================== CARD CREATION ====================
const cards = [];
const textureLoader = new THREE.TextureLoader();

const images = [
  'https://images.unsplash.com/photo-1594552072238-146d88069000?w=900',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0922?w=900',
  'https://images.unsplash.com/photo-1591369822096-ffd140ec948f?w=900',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca0?w=900',
  'https://images.unsplash.com/photo-1623141629340-4686b7d0d5e8?w=900',
  'https://images.unsplash.com/photo-1600003014755-ba31aa59c4b6?w=900',
  'https://images.unsplash.com/photo-1595852855839-7bd7be670dd3?w=900',
  'https://images.unsplash.com/photo-1619810191548-d0c6ee3e9fbe?w=900',
  'https://images.unsplash.com/photo-1583939003579-730e3918a45a?w=900',
  'https://images.unsplash.com/photo-1617038260897-41a1f14a8ca1?w=900',
  'https://images.unsplash.com/photo-1606800052052-bbfa8c0f0920?w=900',
  'https://images.unsplash.com/photo-1594552072238-146d88069001?w=900'
];

const angleStep = (Math.PI * 2) / CONFIG.cardCount;

for (let i = 0; i < CONFIG.cardCount; i++) {
  const cardGroup = new THREE.Group();
  const angle = i * angleStep;
  
  // Position in circle
  cardGroup.position.x = Math.sin(angle) * CONFIG.cylinderRadius;
  cardGroup.position.z = Math.cos(angle) * CONFIG.cylinderRadius;
  cardGroup.rotation.y = angle;
  
  // HIGH TESSELLATION geometry (CRITICAL for smooth bending!)
  const geometry = new THREE.PlaneGeometry(
    CONFIG.cardWidth,
    CONFIG.cardHeight,
    CONFIG.segments,
    CONFIG.segments
  );
  
  const texture = textureLoader.load(images[i]);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  
  const material = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uTexture: { value: texture },
      uBendFactor: { value: 1.0 },
      uExpansionX: { value: 1.0 },
      uExpansionY: { value: 1.0 },
      uZOffset: { value: 0.0 },
      uVelocity: { value: 0.0 },
      uMouse: { value: new THREE.Vector2(0.5, 0.5) },
      uTime: { value: 0.0 },
      uHoverProgress: { value: 0.0 },
      uBrightness: { value: 1.0 }
    },
    side: THREE.DoubleSide,
    transparent: false
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  
  // CRITICAL: Depth management setup
  mesh.renderOrder = 0;
  material.depthWrite = true;
  material.depthTest = true;
  
  cardGroup.add(mesh);
  worldPivot.add(cardGroup);
  
  cards.push({
    group: cardGroup,
    mesh: mesh,
    baseAngle: angle,
    index: i
  });
}

// ==================== INTERACTION STATE ====================
let scrollVelocity = 0;
let currentRotation = 0;
let hoveredCard = null;

const mouse = new THREE.Vector2();
const mouseNormalized = new THREE.Vector2(0.5, 0.5);
const raycaster = new THREE.Raycaster();

// ==================== EVENT LISTENERS ====================
window.addEventListener('wheel', (e) => {
  scrollVelocity -= e.deltaY * CONFIG.scrollSensitivity;
});

const cursor = document.querySelector('.cursor');

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  
  mouseNormalized.x = e.clientX / window.innerWidth;
  mouseNormalized.y = 1.0 - (e.clientY / window.innerHeight);
  
  // Cursor follow
  gsap.to(cursor, {
    x: e.clientX,
    y: e.clientY,
    duration: 0.4,
    ease: 'power2.out'
  });
});

// ==================== HOVER DETECTION ====================
function updateHoverState() {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cards.map(c => c.mesh));
  
  if (intersects.length > 0) {
    const newHovered = cards.find(c => c.mesh === intersects[0].object);
    
    if (hoveredCard !== newHovered) {
      // Deactivate previous
      if (hoveredCard) {
        deactivateCard(hoveredCard);
      }
      
      // Activate new
      hoveredCard = newHovered;
      activateCard(hoveredCard);
      cursor.classList.add('active');
    }
    
    // Update mouse uniforms for cloth effect
    hoveredCard.mesh.material.uniforms.uMouse.value.copy(mouseNormalized);
    
  } else {
    if (hoveredCard) {
      deactivateCard(hoveredCard);
      hoveredCard = null;
      cursor.classList.remove('active');
    }
  }
}

function activateCard(card) {
  const m = card.mesh.material.uniforms;
  
  // CRITICAL: Set render order IMMEDIATELY
  card.mesh.renderOrder = 1000;
  
  // Elastic expansion animation
  gsap.to(m.uBendFactor, {
    value: 0.0,
    duration: CONFIG.hoverDuration,
    ease: 'elastic.out(1, 0.6)'
  });
  
  gsap.to(m.uExpansionX, {
    value: CONFIG.hoverExpansionX,
    duration: CONFIG.hoverDuration,
    ease: 'elastic.out(1, 0.6)'
  });
  
  gsap.to(m.uExpansionY, {
    value: CONFIG.hoverExpansionY,
    duration: CONFIG.hoverDuration,
    ease: 'power3.out'
  });
  
  gsap.to(m.uZOffset, {
    value: CONFIG.hoverZOffset,
    duration: CONFIG.hoverDuration,
    ease: 'power3.out'
  });
  
  gsap.to(m.uHoverProgress, {
    value: 1.0,
    duration: CONFIG.hoverDuration,
    ease: 'power2.out'
  });
  
  gsap.to(m.uBrightness, {
    value: 1.12,
    duration: 0.4
  });
}

function deactivateCard(card) {
  const m = card.mesh.material.uniforms;
  
  gsap.to(m.uBendFactor, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.8,
    ease: 'power2.inOut'
  });
  
  gsap.to(m.uExpansionX, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.8,
    ease: 'power2.inOut'
  });
  
  gsap.to(m.uExpansionY, {
    value: 1.0,
    duration: CONFIG.hoverDuration * 0.8,
    ease: 'power2.inOut'
  });
  
  gsap.to(m.uZOffset, {
    value: 0.0,
    duration: CONFIG.hoverDuration * 0.8,
    ease: 'power2.inOut'
  });
  
  gsap.to(m.uHoverProgress, {
    value: 0.0,
    duration: CONFIG.hoverDuration * 0.8,
    ease: 'power2.inOut'
  });
  
  gsap.to(m.uBrightness, {
    value: 1.0,
    duration: 0.5,
    onComplete: () => {
      // Reset render order only after animation completes
      if (m.uHoverProgress.value < 0.01) {
        card.mesh.renderOrder = 0;
      }
    }
  });
}

// ==================== ANIMATION LOOP ====================
let time = 0;

function animate() {
  requestAnimationFrame(animate);
  time += 0.016;
  
  // ============================================
  // 1. SCROLL PHYSICS
  // ============================================
  scrollVelocity *= CONFIG.friction;
  currentRotation += scrollVelocity;
  worldPivot.rotation.y = currentRotation;
  
  // ============================================
  // 2. WORLD TILT (Y-axis response to mouse)
  // ============================================
  const targetPitch = -0.12 + (mouse.y * CONFIG.worldTiltStrength);
  worldPivot.rotation.x = THREE.MathUtils.lerp(
    worldPivot.rotation.x,
    targetPitch,
    0.08
  );
  
  // Camera subtle shift
  gsap.to(camera.position, {
    x: -mouse.x * 1.2,
    y: 2.5 + mouse.y * 0.6,
    duration: 1.8,
    ease: 'power2.out'
  });
  
  // ============================================
  // 3. HOVER DETECTION
  // ============================================
  updateHoverState();
  
  // ============================================
  // 4. UPDATE CARD UNIFORMS
  // ============================================
  cards.forEach(card => {
    const m = card.mesh.material.uniforms;
    m.uTime.value = time;
    m.uVelocity.value = scrollVelocity * 45;
  });
  
  renderer.render(scene, camera);
}

// ==================== RESIZE ====================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==================== INTRO ANIMATION ====================
gsap.from(camera.position, {
  z: 55,
  duration: 2.8,
  ease: 'power3.out',
  delay: 0.3
});

cards.forEach((card, i) => {
  gsap.from(card.mesh.material.uniforms.uBrightness, {
    value: 0,
    duration: 1.8,
    delay: 0.5 + i * 0.06,
    ease: 'power2.out'
  });
});

// ==================== START ====================
animate();
</script>

</body>
</html>
