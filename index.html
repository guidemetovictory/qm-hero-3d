<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QM Hero 3D – Ring Cards</title>

  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#fff}
    #wrap{position:relative;width:100vw;height:100vh;overflow:hidden;background:#fff}
    canvas{position:absolute;inset:0;display:block;z-index:1}

    #grain{
      position:absolute; inset:0; z-index:2; pointer-events:none;
      mix-blend-mode:multiply; opacity:.18;
      background:
        radial-gradient(circle at 20% 10%, rgba(0,0,0,.10), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(0,0,0,.06), transparent 60%),
        radial-gradient(circle at 50% 80%, rgba(0,0,0,.08), transparent 55%);
      filter: blur(20px);
    }

    #hint{
      position:absolute; top:14px; left:14px; z-index:3;
      font: 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:#0b0b0b; opacity:.55; user-select:none; pointer-events:none;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="hint">Move mouse • Edge-rotate • Snap center • Click focus</div>
    <div id="grain"></div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // -----------------------------
    // Definitions
    // -----------------------------
    // Dead-zone: střední pásmo, kde se nespouští auto-rotace (jen drift).
    // Edge-rotate: pásma u krajů, kde se rotace spouští automaticky podle vzdálenosti od středu.
    // Snap: magnetické přitáhnutí nejbližší karty do středu (když nejsi v edge-rotate a nic není selected).
    // Damping: tlumení rychlosti, aby pohyb působil fyzikálně (ne skokově).

    const wrap = document.getElementById("wrap");

    // -----------------------------
    // Scene
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(48, wrap.clientWidth / wrap.clientHeight, 0.1, 80);
    camera.position.set(0, 0.15, 7.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(2, 3, 4);
    scene.add(dir);

    // -----------------------------
    // Shaders (paper bend)
    // -----------------------------
    const vertex = /* glsl */`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uBend;
      uniform float uHover;

      void main(){
        vUv = uv;
        vec3 p = position;

        float bend = uBend + uHover * 0.60;
        float k = (p.x) * 0.55;
        p.z += sin(k) * bend;

        p.z += sin(uTime * 0.6 + p.y * 1.8) * 0.003;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `;

    const fragment = /* glsl */`
      varying vec2 vUv;
      uniform sampler2D uMap;

      void main(){
        vec4 tex = texture2D(uMap, vUv);

        // IMPORTANT: pokud nechceš "průhledné karty", netahej alpha z textury.
        // Vynutíme plnou neprůhlednost:
        gl_FragColor = vec4(tex.rgb, 1.0);
      }
    `;

    function makePaperMaterial(map){
      return new THREE.ShaderMaterial({
        transparent: false,          // <- žádné průhledno
        side: THREE.DoubleSide,
        uniforms:{
          uTime:{ value:0 },
          uBend:{ value:0.22 },
          uHover:{ value:0.0 },
          uMap:{ value: map }
        },
        vertexShader: vertex,
        fragmentShader: fragment
      });
    }

    // -----------------------------
    // Cards ring
    // -----------------------------
    const group = new THREE.Group();
    scene.add(group);

    const CARD_W = 2.05;
    const CARD_H = 2.80;
    const SEG_X = 36;
    const SEG_Y = 18;

    const N = 10;
    const R = 3.85;

    function makeCardTexture(label){
      const c = document.createElement("canvas");
      c.width = 900; c.height = 1200;
      const g = c.getContext("2d");

      // bg
      g.fillStyle = "rgba(0,0,0,0.16)";
      g.fillRect(0,0,c.width,c.height);

      // highlight
      const grd = g.createRadialGradient(250,220,40, 260,260,700);
      grd.addColorStop(0,"rgba(255,255,255,0.18)");
      grd.addColorStop(1,"rgba(255,255,255,0.00)");
      g.fillStyle = grd;
      g.fillRect(0,0,c.width,c.height);

      // border
      g.strokeStyle = "rgba(255,255,255,0.22)";
      g.lineWidth = 6;
      g.strokeRect(40,40,c.width-80,c.height-80);

      // label
      g.fillStyle = "rgba(15,15,15,0.88)";
      g.font = "700 82px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText(label, 90, 160);

      g.fillStyle = "rgba(15,15,15,0.55)";
      g.font = "500 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText("QM card", 90, 235);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.needsUpdate = true;
      return tex;
    }

    const cards = [];
    for(let i=0;i<N;i++){
      const geo = new THREE.PlaneGeometry(CARD_W, CARD_H, SEG_X, SEG_Y);
      const tex = makeCardTexture(`Card ${i+1}`);
      const mat = makePaperMaterial(tex);
      const mesh = new THREE.Mesh(geo, mat);

      const theta = i * (Math.PI * 2 / N);
      mesh.position.set(Math.cos(theta) * R, 0, Math.sin(theta) * R);

      mesh.lookAt(0, 0, 0);
      mesh.rotateY(Math.PI); // front face to camera on near side

      group.add(mesh);

      cards.push({
        mesh, mat,
        theta,
        hover: 0,
        // animation state
        pop: 0,        // 0..1
        fade: 0        // 0..1 (for de-emphasis)
      });
    }

    // -----------------------------
    // Input state
    // -----------------------------
    let mouseX = 0, mouseY = 0; // normalized -1..1
    let pointerDown = false;

    window.addEventListener("mousemove", (e)=>{
      mouseX = (e.clientX / window.innerWidth) * 2 - 1;
      mouseY = (e.clientY / window.innerHeight) * 2 - 1;
    }, { passive:true });

    window.addEventListener("pointerdown", ()=>{ pointerDown = true; }, { passive:true });
    window.addEventListener("pointerup", ()=>{ pointerDown = false; }, { passive:true });

    // -----------------------------
    // Raycast click select
    // -----------------------------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let selected = null; // index or null

    function raycast(){
      ndc.set(mouseX, -mouseY);
      raycaster.setFromCamera(ndc, camera);
      return raycaster.intersectObjects(cards.map(c=>c.mesh), false);
    }

    window.addEventListener("click", ()=>{
      const hits = raycast();
      if(hits.length){
        const hitObj = hits[0].object;
        const idx = cards.findIndex(c => c.mesh === hitObj);
        selected = (idx >= 0) ? idx : null;
      } else {
        selected = null;
      }
    });

    // -----------------------------
    // Motion: edge-rotate + snap
    // -----------------------------
    let rotY = 0;
    let rotVel = 0;

    const DEAD = 0.35;      // center dead-zone in normalized units
    const EDGE = 0.78;      // edge threshold
    const MAX_VEL = 0.018;  // cap rotation speed
    const DAMP = 0.88;      // velocity damping

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // Returns angle error for bringing a given card to "front center"
    function centerErrorForCard(i){
      // We want that card's world angle aligns to camera "front".
      // With our layout, front is roughly along +Z toward camera, but we rotate group.
      const theta = cards[i].theta;
      // card is at angle theta + rotY around Y
      // target: make it near 0 (so it sits at front). We'll define "front" as theta+rotY ≈ 0.
      let a = theta + rotY;
      // normalize to [-pi, pi]
      a = Math.atan2(Math.sin(a), Math.cos(a));
      return a; // error in radians
    }

    function findClosestToCenter(){
      let best = 0, bestAbs = Infinity;
      for(let i=0;i<N;i++){
        const e = centerErrorForCard(i);
        const ae = Math.abs(e);
        if(ae < bestAbs){ bestAbs = ae; best = i; }
      }
      return { idx: best, err: centerErrorForCard(best), absErr: Math.abs(centerErrorForCard(best)) };
    }

    // -----------------------------
    // Hover bend (optional)
    // -----------------------------
    function updateHover(){
      const hits = raycast();
      for(const c of cards) c.hover *= 0.90;
      if(hits.length){
        const hit = hits[0].object;
        const c = cards.find(x=>x.mesh === hit);
        if(c) c.hover = Math.min(1, c.hover + 0.20);
      }
    }

    // -----------------------------
    // Resize
    // -----------------------------
    function onResize(){
      camera.aspect = wrap.clientWidth / wrap.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    }
    window.addEventListener("resize", onResize);

    // -----------------------------
    // Animate
    // -----------------------------
    const clock = new THREE.Clock();

    function tick(){
      const t = clock.getElapsedTime();

      // 1) Tilt the whole ring gently by mouseY
      const tiltX = clamp(-mouseY * 0.18, -0.22, 0.22);
      group.rotation.x = lerp(group.rotation.x, tiltX, 0.08);

      // 2) Edge-trigger rotation zones
      const ax = Math.abs(mouseX);
      const sign = mouseX < 0 ? -1 : 1;

      // Base influence (center = almost none, edges = strong)
      let edgeInfluence = 0;
      if(ax > DEAD){
        // ramp up from DEAD..1
        const u = (ax - DEAD) / (1 - DEAD);
        edgeInfluence = u*u; // quadratic ramp
      }

      // Stronger beyond EDGE
      let boost = 1.0;
      if(ax > EDGE){
        const v = (ax - EDGE) / (1 - EDGE);
        boost = 1.0 + v * 1.6;
      }

      // If a card is selected, stop edge rotation (focus mode)
      if(selected === null){
        // convert influence to target velocity
        const targetVel = clamp(sign * edgeInfluence * MAX_VEL * boost, -MAX_VEL, MAX_VEL);
        // accelerate velocity toward target
        rotVel = lerp(rotVel, targetVel, 0.10);
      } else {
        // freeze rotation speed in focus mode
        rotVel = lerp(rotVel, 0, 0.12);
      }

      // apply damping and integrate
      rotVel *= DAMP;
      rotY += rotVel;
      group.rotation.y = rotY;

      // 3) Snap-to-center magnet (only when not in edge zone and not selected)
      // Condition: near center band OR low velocity, so it "locks" nicely.
      if(selected === null){
        const { idx, err, absErr } = findClosestToCenter();

        const nearCenterBand = (Math.abs(mouseX) < 0.55); // your “middle pásmo”
        const slow = Math.abs(rotVel) < 0.0035;

        // absErr is in radians; convert approx to pixels mentally: we treat < ~0.18 rad as "almost centered"
        if(nearCenterBand && slow && absErr < 0.22){
          // pull rotY by a fraction of the error (opposite sign)
          rotY += (-err) * 0.06;
          group.rotation.y = rotY;
        }
      }

      // 4) Hover bend + uniforms
      updateHover();
      for(const c of cards){
        c.mat.uniforms.uTime.value = t;
        c.mat.uniforms.uHover.value = c.hover;
      }

      // 5) Click focus animation (selected pop + others de-emphasize)
      for(let i=0;i<N;i++){
        const c = cards[i];

        const isSel = (selected === i);
        const targetPop = isSel ? 1 : 0;

        // Others fade when selected exists
        const targetFade = (selected !== null && !isSel) ? 1 : 0;

        c.pop = lerp(c.pop, targetPop, 0.10);
        c.fade = lerp(c.fade, targetFade, 0.10);

        // Move outward along its local normal (Z in card space), but we need world-ish.
        // Easiest: translate on card's local Z (it faces outward by our lookAt + rotateY).
        const popDist = 0.95;         // how much it comes out
        const backDist = 0.35;        // how much others go back
        const yLift = 0.10;           // subtle lift

        // Reset base position on ring each frame (deterministic)
        const baseTheta = c.theta;
        c.mesh.position.set(Math.cos(baseTheta) * R, 0, Math.sin(baseTheta) * R);

        // Apply pop/back in local space
        // Selected: forward (negative local z because we rotated), Others: backward
        if(isSel){
          c.mesh.translateZ(-popDist * c.pop);
          c.mesh.position.y += yLift * c.pop;
          c.mesh.scale.setScalar(1 + 0.10 * c.pop);
        } else {
          c.mesh.translateZ(+backDist * c.fade);
          c.mesh.scale.setScalar(1);
        }

        // Visual de-emphasis: use material opacity via shader? (we forced opaque)
        // We'll emulate dimming by multiplying renderer color via mesh material color is not available in ShaderMaterial,
        // so simplest is to adjust bend and slight y wobble; for true dimming we'd add a uniform.
        // Quick trick: reduce hover/bend response on faded cards:
        c.mat.uniforms.uHover.value *= (1 - 0.85 * c.fade);
        c.mat.uniforms.uBend.value = lerp(0.22, 0.10, c.fade);
      }

      // 6) Camera parallax (subtle)
      camera.position.x = mouseX * 0.18;
      camera.position.y = 0.15 + (-mouseY) * 0.10;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    tick();
  </script>
</body>
</html>
