<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QM Hero 3D – Ring Cards</title>

  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#fff}
    #wrap{position:relative;width:100vw;height:100vh;overflow:hidden;background:#fff}
    canvas{position:absolute;inset:0;display:block;z-index:1}

    #grain{
      position:absolute; inset:0; z-index:2; pointer-events:none;
      mix-blend-mode:multiply; opacity:.18;
      background:
        radial-gradient(circle at 20% 10%, rgba(0,0,0,.10), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(0,0,0,.06), transparent 60%),
        radial-gradient(circle at 50% 80%, rgba(0,0,0,.08), transparent 55%);
      filter: blur(20px);
    }

    #hint{
      position:absolute; top:14px; left:14px; z-index:3;
      font: 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:#0b0b0b; opacity:.55; user-select:none; pointer-events:none;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="hint">Move mouse • Edge rotate • Front-only click • Auto-center focus</div>
    <div id="grain"></div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // -----------------------------
    // Helpers
    // -----------------------------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const angNorm = (a)=>Math.atan2(Math.sin(a), Math.cos(a)); // [-pi,pi]

    // -----------------------------
    // Scene
    // -----------------------------
    const wrap = document.getElementById("wrap");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(48, wrap.clientWidth / wrap.clientHeight, 0.1, 80);
    camera.position.set(0, 0.15, 7.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    wrap.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x111111, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(2, 3, 4);
    scene.add(dir);

    // -----------------------------
    // Shaders (paper bend)
    // -----------------------------
    const vertex = /* glsl */`
      varying vec2 vUv;
      uniform float uTime;
      uniform float uBend;
      uniform float uHover;

      void main(){
        vUv = uv;
        vec3 p = position;
        float bend = uBend + uHover * 0.60;
        float k = (p.x) * 0.55;
        p.z += sin(k) * bend;
        p.z += sin(uTime * 0.6 + p.y * 1.8) * 0.003;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `;

    // Force opaque cards (no “transparent” surprises)
    const fragment = /* glsl */`
      varying vec2 vUv;
      uniform sampler2D uMap;
      uniform float uDim; // 0..1 (0 normal, 1 dim)
      void main(){
        vec4 tex = texture2D(uMap, vUv);
        vec3 col = tex.rgb;
        // dim others in focus mode
        col = mix(col, col * 0.30, uDim);
        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function makePaperMaterial(map){
      return new THREE.ShaderMaterial({
        transparent: false,
        side: THREE.DoubleSide,
        uniforms:{
          uTime:{ value:0 },
          uBend:{ value:0.22 },
          uHover:{ value:0.0 },
          uDim:{ value:0.0 },
          uMap:{ value: map }
        },
        vertexShader: vertex,
        fragmentShader: fragment
      });
    }

    // -----------------------------
    // Ring + Cards
    // -----------------------------
    const group = new THREE.Group();
    scene.add(group);

    const CARD_W = 2.05, CARD_H = 2.80;
    const SEG_X = 36, SEG_Y = 18;
    const N = 10;
    const R = 3.85;

    function makeCardTexture(label){
      const c = document.createElement("canvas");
      c.width = 900; c.height = 1200;
      const g = c.getContext("2d");

      g.fillStyle = "rgba(0,0,0,0.16)";
      g.fillRect(0,0,c.width,c.height);

      const grd = g.createRadialGradient(250,220,40, 260,260,700);
      grd.addColorStop(0,"rgba(255,255,255,0.18)");
      grd.addColorStop(1,"rgba(255,255,255,0.00)");
      g.fillStyle = grd;
      g.fillRect(0,0,c.width,c.height);

      g.strokeStyle = "rgba(255,255,255,0.22)";
      g.lineWidth = 6;
      g.strokeRect(40,40,c.width-80,c.height-80);

      g.fillStyle = "rgba(15,15,15,0.88)";
      g.font = "700 82px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText(label, 90, 160);

      g.fillStyle = "rgba(15,15,15,0.55)";
      g.font = "500 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText("QM card", 90, 235);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.needsUpdate = true;
      return tex;
    }

    const cards = [];
    for(let i=0;i<N;i++){
      const geo = new THREE.PlaneGeometry(CARD_W, CARD_H, SEG_X, SEG_Y);
      const tex = makeCardTexture(`Card ${i+1}`);
      const mat = makePaperMaterial(tex);
      const mesh = new THREE.Mesh(geo, mat);

      const theta = i * (Math.PI * 2 / N);
      mesh.position.set(Math.cos(theta) * R, 0, Math.sin(theta) * R);

      mesh.lookAt(0,0,0);
      mesh.rotateY(Math.PI); // consistent face

      group.add(mesh);
      cards.push({ mesh, mat, theta, hover:0, pop:0 });
    }

    // -----------------------------
    // Input + Raycast
    // -----------------------------
    let mouseX = 0, mouseY = 0;
    window.addEventListener("mousemove",(e)=>{
      mouseX = (e.clientX / window.innerWidth) * 2 - 1;
      mouseY = (e.clientY / window.innerHeight) * 2 - 1;
    }, { passive:true });

    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    function raycast(){
      ndc.set(mouseX, -mouseY);
      raycaster.setFromCamera(ndc, camera);
      return raycaster.intersectObjects(cards.map(c=>c.mesh), false);
    }

    function hoveredIndex(){
      const hits = raycast();
      if(!hits.length) return null;
      const obj = hits[0].object;
      const idx = cards.findIndex(c=>c.mesh===obj);
      return (idx>=0) ? idx : null;
    }

    // -----------------------------
    // Rotation model (velocity + zones)
    // -----------------------------
    let rotY = 0;
    let rotVel = 0;

    const DEAD = 0.35;
    const EDGE = 0.78;
    const MAX_VEL = 0.020;
    const DAMP = 0.88;

    // -----------------------------
    // Focus state machine
    // -----------------------------
    // free: edge-rotate zones active
    // focusing: auto-center to selected
    // focused: selected card popped; others dimmed
    let state = "free";          // "free" | "focusing" | "focused"
    let selected = null;         // index or null
    let focusTargetRotY = 0;     // where ring should rotate to center selected

    // Only allow click on front cluster
    function centerErrorForCard(i){
      const a = angNorm(cards[i].theta + rotY);
      return a; // want ~0 for center/front
    }

    function isSelectable(i){
      // front cluster: near center + in front (world z > 0)
      const err = Math.abs(centerErrorForCard(i));
      const wpos = new THREE.Vector3();
      cards[i].mesh.getWorldPosition(wpos);
      return (err < 0.55) && (wpos.z > 0.0); // tune if needed
    }

    function beginFocus(i){
      selected = i;
      // Make selected centered: theta + rotY = 0 => rotY = -theta (normalized around current)
      const err = centerErrorForCard(i);
      focusTargetRotY = rotY - err; // subtract current error
      state = "focusing";
    }

    function cancelFocus(){
      state = "free";
      selected = null;
    }

    window.addEventListener("click", ()=>{
      const hits = raycast();
      if(!hits.length){
        cancelFocus();
        return;
      }
      const idx = hoveredIndex();
      if(idx === null) { cancelFocus(); return; }

      // If already focused and clicking selected => toggle back
      if(selected === idx && (state==="focused" || state==="focusing")){
        cancelFocus();
        return;
      }

      // Only allow selecting front cluster
      if(isSelectable(idx)){
        beginFocus(idx);
      } else {
        // click on non-front card does nothing (or cancels focus if you want)
        // cancelFocus();
      }
    });

    // -----------------------------
    // Animate
    // -----------------------------
    const clock = new THREE.Clock();
    const tmpV = new THREE.Vector3();
    const tmpDir = new THREE.Vector3();

    function tick(){
      const t = clock.getElapsedTime();

      // Tilt whole ring up/down based on mouseY (always)
      const tiltX = clamp(-mouseY * 0.18, -0.22, 0.22);
      group.rotation.x = lerp(group.rotation.x, tiltX, 0.08);

      // Hover bend
      const hIdx = hoveredIndex();
      for(let i=0;i<N;i++){
        cards[i].hover *= 0.90;
        if(hIdx === i) cards[i].hover = Math.min(1, cards[i].hover + 0.20);
        cards[i].mat.uniforms.uTime.value = t;
        cards[i].mat.uniforms.uHover.value = cards[i].hover;
      }

      // AUTO-CANCEL: pokud je něco vybrané a ty najedeš na jinou kartu nebo mimo vybranou, focus se zruší
      if(selected !== null && (state==="focused" || state==="focusing")){
        if(hIdx === null || hIdx !== selected){
          cancelFocus();
        }
      }

      // ROTATION
      if(state === "free"){
        // edge zones drive velocity
        const ax = Math.abs(mouseX);
        const sign = (mouseX < 0) ? -1 : 1;

        let influence = 0;
        if(ax > DEAD){
          const u = (ax - DEAD) / (1 - DEAD);
          influence = u*u;
        }

        let boost = 1.0;
        if(ax > EDGE){
          const v = (ax - EDGE) / (1 - EDGE);
          boost = 1.0 + v * 1.6;
        }

        const targetVel = clamp(sign * influence * MAX_VEL * boost, -MAX_VEL, MAX_VEL);
        rotVel = lerp(rotVel, targetVel, 0.10);

        rotVel *= DAMP;
        rotY += rotVel;
      }

      if(state === "focusing"){
        // spring-ish converge to focusTargetRotY
        const err = angNorm(focusTargetRotY - rotY);
        rotVel = rotVel * 0.80 + err * 0.06; // accel toward target
        rotVel *= 0.86;
        rotY += rotVel;

        if(Math.abs(err) < 0.008 && Math.abs(rotVel) < 0.002){
          rotY = focusTargetRotY;
          rotVel = 0;
          state = "focused";
        }
      }

      if(state === "focused"){
        // keep locked (tiny damping)
        const err = angNorm(focusTargetRotY - rotY);
        rotY += err * 0.08;
        rotVel *= 0.6;
      }

      group.rotation.y = rotY;

      // POP / DIM
      for(let i=0;i<N;i++){
        const c = cards[i];
        const isSel = (selected === i);

        // deterministic base ring pos (do NOT move card into center of ring)
        const th = c.theta;
        c.mesh.position.set(Math.cos(th) * R, 0, Math.sin(th) * R);

        // orientation stays correct
        c.mesh.lookAt(0,0,0);
        c.mesh.rotateY(Math.PI);

        // target pop: only when fully focused (or during focusing)
        const targetPop = (isSel && (state==="focused" || state==="focusing")) ? 1 : 0;
        c.pop = lerp(c.pop, targetPop, 0.10);

        // dim others during focus
        const dim = (selected !== null && !isSel) ? 1 : 0;
        c.mat.uniforms.uDim.value = lerp(c.mat.uniforms.uDim.value, dim, 0.12);

        // IMPORTANT FIX:
        // move selected toward camera in WORLD direction (camera - card), not local Z (which can go inward)
        if(isSel){
          c.mesh.getWorldPosition(tmpV);
          tmpDir.copy(camera.position).sub(tmpV).normalize(); // direction TO camera
          const popDist = 1.00;
          c.mesh.position.add(tmpDir.multiplyScalar(popDist * c.pop));
          c.mesh.scale.setScalar(1 + 0.10 * c.pop);
        } else {
          // push others slightly backward when focus active
          if(selected !== null){
            c.mesh.getWorldPosition(tmpV);
            tmpDir.copy(camera.position).sub(tmpV).normalize();
            const back = 0.30;
            c.mesh.position.add(tmpDir.multiplyScalar(-back * c.mat.uniforms.uDim.value)); // away from camera
          }
          c.mesh.scale.setScalar(1);
        }
      }

      // Camera parallax (subtle)
      camera.position.x = mouseX * 0.18;
      camera.position.y = 0.15 + (-mouseY) * 0.10;
      camera.lookAt(0,0,0);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // Resize
    window.addEventListener("resize", ()=>{
      camera.aspect = wrap.clientWidth / wrap.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    });

    tick();
  </script>
</body>
</html>
