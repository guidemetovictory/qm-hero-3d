<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>Milla Nova | 1:1 Engineering Replica</title>
    <style>
        body { margin: 0; background: #ececec; overflow: hidden; font-family: serif; }
        #canvas-container { position: fixed; inset: 0; }
        #explore-cursor {
            position: fixed; width: 120px; height: 120px; background: #a3322d; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; color: #fff;
            font-size: 11px; text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none; z-index: 1000; opacity: 0; transform: scale(0);
            will-change: transform;
        }
        .ui {
            position: fixed; inset: 0; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 50px;
        }
        .ui div { opacity: 0.5; letter-spacing: 3px; font-size: 12px; }
    </style>
</head>
<body>

<div id="explore-cursor">Explore</div>
<div id="canvas-container"></div>
<div class="ui">
    <div style="text-align: center">MILLA NOVA — COUTURE</div>
    <div style="display: flex; justify-content: space-between">
        <span>COLLECTION 2025</span>
        <span>SCROLL TO EXPLORE</span>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { gsap } from 'https://cdn.skypack.dev/gsap';

    // --- ARCHITEKTURA A KONFIGURACE ---
    const CONFIG = {
        radius: window.innerWidth < 768 ? 11 : 16,
        cardCount: 14,
        cardWidth: 5,
        cardHeight: 7.2,
        lerp: 0.05,
        zoomDistance: 8.5
    };

    const titles = ["Amour", "Couture", "Silk Way", "Ethereal", "Elegance", "Heritage", "Muse", "Nightfall", "Grace", "Timeless", "Ivory", "Petals", "Divine", "Luna"];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xececec);
    scene.fog = new THREE.Fog(0xececec, 15, 45);

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- SHADERY (Srdce vizuálu) ---
    const vertexShader = `
        uniform float uBend;
        uniform float uRadius;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec3 pos = position;
            // Matematicky přesný ohyb válce
            float angle = pos.x / uRadius;
            pos.z += (cos(angle * uBend) * uRadius - uRadius);
            pos.x = sin(angle * uBend) * uRadius;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `;

    const fragmentShader = `
        uniform sampler2D uMap;
        uniform float uOpacity;
        uniform float uHover;
        uniform float uTime;
        varying vec2 vUv;

        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 tex = texture2D(uMap, vUv);
            // Film grain šum
            float n = noise(vUv + uTime * 0.01) * 0.06;
            // Dynamické nasvícení hran (Rim lighting)
            float edge = smoothstep(0.47, 0.5, abs(vUv.x - 0.5));
            float rim = pow(edge, 3.5) * 0.3 * (1.0 - uHover);
            
            vec3 color = tex.rgb + rim + n;
            // Focus gradient (ztmavení neaktivních)
            color = mix(color * 0.35, color, uOpacity);
            gl_FragColor = vec4(color, uOpacity);
        }
    `;

    // --- TVORBA OBJEKTŮ ---
    function createText(txt) {
        const can = document.createElement('canvas');
        const ctx = can.getContext('2d');
        can.width = 1024; can.height = 256;
        ctx.font = '300 70px serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt.toUpperCase(), 512, 128);
        const t = new THREE.CanvasTexture(can);
        t.needsUpdate = true; return t;
    }

    const worldPivot = new THREE.Group();
    scene.add(worldPivot);

    const cards = [];
    const loader = new THREE.TextureLoader();

    for (let i = 0; i < CONFIG.cardCount; i++) {
        const group = new THREE.Group();
        const angle = (i / CONFIG.cardCount) * Math.PI * 2;
        group.rotation.y = angle;
        worldPivot.add(group);

        const wrapper = new THREE.Group();
        wrapper.position.z = CONFIG.radius;
        group.add(wrapper);

        // Karta Mesh
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uMap: { value: loader.load(`https://picsum.photos/1000/1500?v=${i}`) },
                uBend: { value: 1.0 },
                uRadius: { value: CONFIG.radius },
                uOpacity: { value: 1.0 },
                uHover: { value: 0.0 },
                uTime: { value: 0.0 }
            },
            vertexShader, fragmentShader, transparent: true, side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight, 64, 1), mat);
        wrapper.add(mesh);

        // Text Mesh
        const tMat = new THREE.ShaderMaterial({
            uniforms: { uMap: { value: createText(titles[i]) }, uBend: { value: 1.0 }, uRadius: { value: CONFIG.radius }, uOpacity: { value: 0.0 } },
            vertexShader,
            fragmentShader: `uniform sampler2D uMap; uniform float uOpacity; varying vec2 vUv; void main() { vec4 c = texture2D(uMap, vUv); gl_FragColor = vec4(c.rgb, c.a * uOpacity); }`,
            transparent: true
        });
        const tMesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.cardWidth, 1.5, 64, 1), tMat);
        tMesh.position.y = CONFIG.cardHeight / 2 + 1;
        wrapper.add(tMesh);

        cards.push({ group, wrapper, mesh, tMesh, angle });
    }

    // --- INTERAKCE A ANIMACE ---
    let targetRot = 0, currentRot = 0, mouse = new THREE.Vector2(), isZoomed = false, activeCard = null;
    const raycaster = new THREE.Raycaster();

    window.addEventListener('wheel', (e) => { if(!isZoomed) targetRot -= e.deltaY * 0.0008; });
    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        gsap.to("#explore-cursor", { x: e.clientX, y: e.clientY, duration: 0.2 });
    });

    window.addEventListener('click', () => {
        if(isZoomed) { returnToGallery(); return; }
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(cards.map(c => c.mesh));
        if(hits.length > 0) {
            activeCard = cards.find(c => c.mesh === hits[0].object);
            zoomIn(activeCard);
        }
    });

    function zoomIn(card) {
        isZoomed = true;
        const tl = gsap.timeline();
        // 1. Vyrovnání rotace celého světa na kartu
        tl.to(worldPivot.rotation, { y: -card.angle, duration: 1.6, ease: "expo.inOut" });
        // 2. Nálet kamery hluboko k objektu
        tl.to(camera.position, { z: CONFIG.zoomDistance, duration: 1.6, ease: "expo.inOut" }, 0);
        // 3. Narovnání ohybu karty (Bend -> 0)
        tl.to(card.mesh.material.uniforms.uBend, { value: 0, duration: 1.4, ease: "power4.out" }, 0.2);
        tl.to(card.wrapper.position, { z: CONFIG.radius + 1, duration: 1.6, ease: "expo.inOut" }, 0);
        // 4. Fade out ostatních
        cards.forEach(c => {
            if(c !== card) {
                tl.to(c.mesh.material.uniforms.uOpacity, { value: 0, duration: 0.6 }, 0);
                tl.to(c.tMesh.material.uniforms.uOpacity, { value: 0, duration: 0.3 }, 0);
            }
        });
    }

    function returnToGallery() {
        const tl = gsap.timeline({ onComplete: () => { isZoomed = false; activeCard = null; } });
        tl.to(camera.position, { z: 30, duration: 1.4, ease: "expo.inOut" });
        tl.to(worldPivot.rotation, { y: currentRot, duration: 1.4, ease: "expo.inOut" }, 0);
        cards.forEach(c => {
            tl.to(c.mesh.material.uniforms.uBend, { value: 1.0, duration: 1.2 }, 0);
            tl.to(c.mesh.material.uniforms.uOpacity, { value: 1.0, duration: 1.0 }, 0);
            tl.to(c.wrapper.position, { z: CONFIG.radius, duration: 1.2 }, 0);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!isZoomed) {
            // Infinite scroll logic
            if (targetRot < -Math.PI) { targetRot += Math.PI*2; currentRot += Math.PI*2; }
            if (targetRot > Math.PI) { targetRot -= Math.PI*2; currentRot -= Math.PI*2; }
            currentRot += (targetRot - currentRot) * CONFIG.lerp;
            worldPivot.rotation.y = currentRot;
        }

        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(cards.map(c => c.mesh));
        let hovered = null;

        cards.forEach(card => {
            card.mesh.material.uniforms.uTime.value = performance.now() * 0.001;
            const worldPos = new THREE.Vector3();
            card.mesh.getWorldPosition(worldPos);
            const dist = Math.abs(worldPos.x);
            
            if(!isZoomed) {
                // Focus & Text Visibility logic
                const opacityWeight = Math.max(0, 1.0 - (dist / 14));
                card.mesh.material.uniforms.uOpacity.value = THREE.MathUtils.lerp(card.mesh.material.uniforms.uOpacity.value, 0.3 + (opacityWeight * 0.7), 0.1);
                card.tMesh.material.uniforms.uOpacity.value = THREE.MathUtils.lerp(card.tMesh.material.uniforms.uOpacity.value, dist < 2.5 ? 1 : 0, 0.1);

                if(hits.length > 0 && hits[0].object === card.mesh) {
                    hovered = card;
                    gsap.to(card.wrapper.position, { z: CONFIG.radius + 2, duration: 0.6 });
                    gsap.to(card.mesh.material.uniforms.uBend, { value: 0.15, duration: 0.6 });
                    gsap.to(card.mesh.material.uniforms.uHover, { value: 1.0, duration: 0.4 });
                } else {
                    gsap.to(card.wrapper.position, { z: CONFIG.radius, duration: 0.8 });
                    gsap.to(card.mesh.material.uniforms.uBend, { value: 1.0, duration: 0.8 });
                    gsap.to(card.mesh.material.uniforms.uHover, { value: 0.0, duration: 0.4 });
                }
            }
        });

        gsap.to("#explore-cursor", { opacity: hovered ? 1 : 0, scale: hovered ? 1 : 1e-4, duration: 0.3 });
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
